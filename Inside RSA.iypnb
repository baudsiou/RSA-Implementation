{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(i) Computing the gcd; (ii) Computing the modular multiplicative inverse (when it exists); (iii) Encryption/Decryption with Textbook RSA; (iv) Signature with Full-Domain Hash"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from functools import reduce\n",
    "import random\n",
    "from Crypto.Util import number\n",
    "from hashlib import sha256\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(i) Computing the gcd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 2 3\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "1"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "#Implement the Greatest Common Divisor (gcd) for any list of numbers\n",
    "\n",
    "''' \n",
    "numbers: A list of numbers given as an input\n",
    "\n",
    "gcd function:\n",
    "In case we have 2 numbers as an input, we return\n",
    "the (greatest) number until the division between him \n",
    "and the other has zero remainder.\n",
    "In case of more than 2 numbers are given, we use the\n",
    "reduce function which applies the GCD() for each number\n",
    "that we have in the list.\n",
    "\n",
    "For instance if we have numbers = [a,b,c,d]\n",
    "what reduce function mainly does in our case is:\n",
    "\n",
    "gcd(a, b, c, d) = gcd(a,b) \n",
    "             = gcd(gcd(a, b), c) \n",
    "             = gcd(gcd(gcd(a, b), c) , d)\n",
    "\n",
    "'''\n",
    "numbers = list(map(int,input().split()))\n",
    "\n",
    "def gcd(numbers):\n",
    "    if len(numbers) == 2:\n",
    "        if numbers[1] == 0:\n",
    "            return numbers[0]\n",
    "        else:\n",
    "            numbers = [numbers[1], numbers[0] % numbers[1]]\n",
    "            return  gcd(numbers)\n",
    "    else:\n",
    "         return reduce(lambda x,y: gcd([x,y]), numbers)\n",
    "\n",
    "        \n",
    "        \n",
    "gcd(numbers)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "gcd = reduce(lambda x,y:GCD([x,y]),[a,b,c,d])\n",
    "\n",
    "#is the same as doing\n",
    "\n",
    "gcd = GCD(a,b)\n",
    "gcd = GCD(gcd,c)\n",
    "gcd = GCD(gcd,d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(ii) Computing the modular multiplicative inverse (when it exists)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Specify the numbers\n",
      "22 3\n",
      "The divisor is 22\n",
      "The dividend is 3\n",
      "The modular multiplicative inverse of 22 is 1\n"
     ]
    }
   ],
   "source": [
    "# Computing the modular multiplicative inverse (when it exists)\n",
    "\n",
    "'''\n",
    "x : a positive integer (the divisor)\n",
    "p : a positive integer (the dividend)\n",
    "Given (x,p) we compute the inverse of x if it exists.\n",
    "Here the parameter numbers = [x,p] \n",
    "\n",
    "'''\n",
    "print(\"Specify the numbers\") \n",
    "x,p= list(map(int,input().split()))\n",
    "print(\"The divisor is\",x)\n",
    "print(\"The dividend is\",p)\n",
    "\n",
    "\n",
    "def inverse(x,p):\n",
    "    if x==1 or p==1:\n",
    "        return 1\n",
    "    if gcd([x,p])!=1:\n",
    "         print(\"The  modular multiplicative inverse of\" ,x,\"with\",p,\"as a dividend does not exist\")     \n",
    "    else:\n",
    "        for i in range(1,p):\n",
    "            if ((x * i) % p == 1):\n",
    "                print(\"The modular multiplicative inverse of\", x ,\"is\",i) \n",
    "                \n",
    "\n",
    "inverse(x,p)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " (iii) Encryption/Decryption with Textbook RSA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "INPUT: Security parameter l\n",
    "OUTPUT: RSA public key e, private key d and n\n",
    "1. Randomly select two primes p and q with same bitlength l/2\n",
    "2. Compute n = pq and phi = (p-1)(q-1)\n",
    "3. Select an arbitrary integer e with 1 < e < phi and gcd(e, phi)==1\n",
    "4. Compute the integer d satisfying 1 < d < phi and ed == 1 mod phi\n",
    "5. Return(n, e, d)\n",
    "\n",
    "\n",
    "Algorithm 1.2: Basic RSA encryption\n",
    "INPUT: RSA public key e, n, plaintext m\n",
    "OUTPUT: Ciphertext c\n",
    "1. Compute c = m**e mod n\n",
    "2. Return(c)\n",
    "Algorithm 1.3: Basic RSA decryption\n",
    "INPUT: RSA private d, n, ciphertext c\n",
    "OUTPUT: Plaintext m\n",
    "1. Compute m = c**d mod n\n",
    "2. Return(m)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Generate random prime numbers with specific length of bits\n",
    "\n",
    "def prime_gen(bit_length):\n",
    "    prime = number.getPrime(bit_length)\n",
    "    return (prime)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "#We choose the encryption \"e\" such that gcd(e,φ(N))=1\n",
    "'''\n",
    "Input : the value of \"φ\" function\n",
    "Output : the encryption \"e\"\n",
    "We randomly pick a candidate number less than φ(Ν)\n",
    "and check if the gcd(e,φ(N))=1\n",
    "'''\n",
    "def encrypt_pow(phi_N):\n",
    "    candidate = [i for i in range(1, phi_N)]\n",
    "    e = random.choice(candidate)\n",
    "    while(gcd([e, phi_N]) != 1):\n",
    "        e = random.choice(candidate)\n",
    "    return e\n",
    "#encrypt_pow(8)        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "## Same function used in RSA textbook\n",
    "\n",
    "def inverse_rsa(x,p):\n",
    "    if x==1 or p==1:\n",
    "        return 1\n",
    "    if gcd([x,p])!=1:\n",
    "         print(\"The  modular multiplicative inverse does not exist\")     \n",
    "    else:\n",
    "        for i in range(1,p):\n",
    "            if ((x * i) % p == 1):\n",
    "                return i\n",
    "                \n",
    "\n",
    "inverse_rsa(5,8)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Generate the public key adn the private key\n",
    "\n",
    "'''\n",
    "Input : number of bits which will define the prime bitlength\n",
    "Output: The primes (p,q),their product (N) and the function phi_N\n",
    "\n",
    "'''\n",
    "def Key_Generation(bits):\n",
    "    # Randomly select 2 primes with same Bitlength l/2\n",
    "    p = prime_gen(bits)\n",
    "    q = prime_gen(bits)\n",
    "    # Compute\n",
    "    N = p * q\n",
    "    phi_N = (p - 1) * (q - 1)\n",
    "    # Select an arbitrary integer e with 1 < e < phi and gcd(e,phi) == 1\n",
    "    e = encrypt_pow(phi_N)\n",
    "    # Compute the integer d statisfying 1 < d < phi and e*d == 1 mod phi\n",
    "    d = inverse_rsa(e, phi_N)\n",
    "    # Return n e d\n",
    "    print(\"Public Key: \" ,e)\n",
    "    print(\"Private Key: \" ,d)\n",
    "    print(\"N=\",N)\n",
    "    return(p,q,N,phi_N,e,d)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Public Key:  97\n",
      "Private Key:  73\n",
      "N= 143\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(13, 11, 143, 120)"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Key_Generation(4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "RSA Encryption Scheme\n",
    "\n",
    "Input: The plaintext m,the RSA public key e and n\n",
    "    \n",
    "Output: The ciphertext c\n",
    "    \n",
    "1. Compute c = m^e mod n\n",
    "2. Return(c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Encryption function\n",
    "\n",
    "'''\n",
    "Input : m (the plaintext) ,e (encr code-public key) , n (the prime product)\n",
    "Output : c (the ciphertext)\n",
    "#ord? - Return the Unicode code point for a one-character string -in our case the encoding of each letter\n",
    "#pow? - x**y % z (with three arguments) here x is the letter enc, y is e and z is n\n",
    "\n",
    "'''\n",
    "\n",
    "def encryption(m,e,N):\n",
    "    c = []\n",
    "    for x in m:\n",
    "        c.append(pow(ord(x),e,N))\n",
    "    #print(int(''.join(map(lambda x: str(x), c))))    \n",
    "    return c\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "RSA Decryption Scheme\n",
    "\n",
    "Input:The ciphertext c,the RSA private key d, and  N\n",
    "    \n",
    "Output: The plaintext m\n",
    "    \n",
    "1. Compute m = c**d mod n\n",
    "2. Return(m)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Decryption function\n",
    "\n",
    "'''\n",
    "Input : c (the ciphertext),d (decr code-private key) , N (the prime product)\n",
    "Output : m (the plaintext) \n",
    "#chr? - Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff\n",
    "(it's like decrypting its unicode code as a string bit)\n",
    "#pow? - x**y % z (with three arguments) here x is the letter enc, y is e and z is n\n",
    "\n",
    "'''\n",
    "\n",
    "\n",
    "def decryption(c,d,N):\n",
    "    m = []\n",
    "    for x in c:\n",
    "        m.append(chr(pow(x,d,N)))\n",
    "    return ''.join(m)\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Decrypt and get the original message (plaintext)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Public Key:  689\n",
      "Private Key:  20009\n",
      "N= 20989\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'CRYPTO IS COOL'"
      ]
     },
     "execution_count": 145,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "m = \"CRYPTO IS COOL\"\n",
    "p,q,N,phi_N,e,d = Key_Generation(8)\n",
    "#e = encrypt_pow(phi_N)\n",
    "c = encryption(m,e,N) \n",
    "#d = inverse_rsa(e,phi_N)\n",
    "decryption(c,d,N)  \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(iv) Signature with Full-Domain Hash"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "from base64 import b64encode, b64decode\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'3f876c1c5458ffee912b10e8200555a0ec5c37b7c76e24c2c27f01ab098d13c1'"
      ]
     },
     "execution_count": 93,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Hash the messagewith SHA-256\n",
    "\n",
    "'''\n",
    "Input : message (the plaintext)\n",
    "Output : The hashed message\n",
    "Procedure : To generate a signature, make a hash from the plaintext, \n",
    "encrypt it with your private key, include it alongside the plaintext.\n",
    "'''\n",
    "\n",
    "\n",
    "\n",
    "def hashFunction(message):\n",
    "    hashed = sha256(message.encode(\"UTF-8\")).hexdigest()\n",
    "    return hashed\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 174,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Authentication Procedure\n",
    "\n",
    "'''\n",
    "Input : receivedeHash (the hash we received after decryption),message (the plaintext)\n",
    "Output : The result of verification \n",
    "\n",
    "Procedure : Make a hash from the plaintext (ourHashed), decrypt the signature with the sender's public key (decrypted_msg),\n",
    "check that both hashes are the same (receivedHash ~ ourHashed)\n",
    "'''\n",
    "\n",
    "\n",
    "\n",
    "def verify(receivedHash, message):\n",
    "    ourHashed = hashFunction(message)\n",
    "    if receivedHash == ourHashed:\n",
    "        print(\"Authentication successful: \", )\n",
    "        print(receivedHash, \" = \", ourHash)\n",
    "    else:\n",
    "        print(\"Authentication failed\")\n",
    "        print(receivedHash, \" != \", ourHash)\n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Main function\n",
    "\n",
    "Input : Number of bits which define the bitlength (bits), the plaintext (message)\n",
    "Output : The public-private generated key pair, the encrypted-decrypted message, the results of the verification process\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 176,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Specify the number of bits for the prime generation:8\n",
      "Enter a message to encrypt with your private key:    ANDREA DI LUCA\n",
      "\n",
      "Public Key:  23087\n",
      "Private Key:  11543\n",
      "N = 42593\n",
      "\n",
      "The encrypted message with public key 23087 is\n",
      "4037040370403702026931869290722727437422202694037029072370734037039873129552989220269\n",
      "\n",
      "The dectrypted message with private key 11543 is\n",
      "   ANDREA DI LUCA\n",
      "\n",
      "Encrypting message with private key  11543  . . .\n",
      "Your signature is : \n",
      "964722825172003369622973172001969096472711541095628326313096741095453326319647545317200172001105656285453562830967901022973254571969027115196905628326313096784655628271152545756289647964741093369690108465562884652297354539647901056281105684655628336968465336963096732631271155453172004109\n",
      "\n",
      "Decrypting message with public key  23087  . . .\n",
      "Your decrypted message is:\n",
      "20da8db216e7465725ddfe5e4983b1be74ce13e226a9cec8529efceaca4715d6\n",
      "\n",
      "Verification results~\n",
      "Authentication successful: \n",
      "20da8db216e7465725ddfe5e4983b1be74ce13e226a9cec8529efceaca4715d6  =  20da8db216e7465725ddfe5e4983b1be74ce13e226a9cec8529efceaca4715d6\n",
      "Enter a message to encrypt with your private key:    EUGE\n",
      "Authentication failed\n",
      "20da8db216e7465725ddfe5e4983b1be74ce13e226a9cec8529efceaca4715d6  !=  caebac26838a6086822f88b99db3cec512724f7d2621ad8257b562124099fc97\n"
     ]
    }
   ],
   "source": [
    "def main():\n",
    "    bits = int(input(\"Specify the number of bits for the prime generation:\"))\n",
    "    message = str(input(\"Enter a message to encrypt with your private key: \"))\n",
    "    #Prime Generation,private and public key\n",
    "    p = prime_gen(bits)\n",
    "    q = prime_gen(bits)\n",
    "    N = p * q\n",
    "    phi_N = (p - 1) * (q - 1)\n",
    "    e = encrypt_pow(phi_N)\n",
    "    d = inverse_rsa(e, phi_N)\n",
    "    print(\"\")\n",
    "    print(\"Public Key: \" ,e)\n",
    "    print(\"Private Key: \" ,d)\n",
    "    print(\"N =\",N)\n",
    "    #Encryption and Decryption\n",
    "    c = encryption(message,e,N)\n",
    "    print(\"\")\n",
    "    print(\"The encrypted message with public key\",e,\"is\")\n",
    "    print(int(''.join(map(lambda x: str(x), c))))\n",
    "    print(\"\")\n",
    "    print(\"The dectrypted message with private key\",d,\"is\")\n",
    "    print(decryption(c,d,N))  \n",
    "    #Sign the message and verify\n",
    "    hashed = hashFunction(message)\n",
    "    print(\"\")\n",
    "    print(\"Encrypting message with private key \", d ,\" . . .\")\n",
    "    encrypted_msg = encryption(hashed,d,N)   \n",
    "    print(\"Your signature is : \")\n",
    "    print(''.join(map(lambda x: str(x), encrypted_msg)))\n",
    "    print(\"\")\n",
    "    print(\"Decrypting message with public key \", e ,\" . . .\")\n",
    "    decrypted_msg = decryption(encrypted_msg,e,N)\n",
    "    print(\"Your decrypted message is:\")  \n",
    "    print(decrypted_msg)\n",
    "    print(\"\")\n",
    "    print(\"Verification results~\")\n",
    "    verify(decrypted_msg, message)\n",
    "    message = str(input(\"Enter a message to encrypt with your private key: \"))\n",
    "    verify(decrypted_msg, message)\n",
    "\n",
    "\n",
    "main()    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
